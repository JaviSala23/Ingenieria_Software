# Clase 2 - Evoluci√≥n Hist√≥rica del Software y el Surgimiento de la Ingenier√≠a de Software

---

## üéØ Objetivo de la clase

Conocer el contexto hist√≥rico que dio origen a la Ingenier√≠a de Software, entender la evoluci√≥n del software y por qu√© se hizo necesario un enfoque m√°s sistem√°tico y profesional para su desarrollo.

---

## üï∞ Etapas de la evoluci√≥n del software

### üßÆ 1. Los comienzos (d√©cadas de 1950-60)

Durante los primeros a√±os de la computaci√≥n, el desarrollo de software no exist√≠a como una actividad separada. Las computadoras eran muy costosas, enormes y dif√≠ciles de operar, y se usaban principalmente con fines cient√≠ficos, militares o administrativos.

---

#### üìç Contexto general

- Las computadoras eran **electromec√°nicas o a v√°lvulas**, como la ENIAC (1946) o la UNIVAC.
- El acceso era limitado: solo grandes instituciones (gobiernos, universidades, empresas multinacionales) pod√≠an adquirirlas.
- No exist√≠a el concepto de ‚Äúusuario‚Äù como lo entendemos hoy.

---

#### üíª ¬øC√≥mo se desarrollaba el software?

- **El software no se "programaba" como hoy.** Se ingresaban instrucciones directamente en lenguaje de m√°quina: cadenas de 0s y 1s que el procesador pod√≠a entender.
- Luego surgieron **lenguajes ensambladores**, que asignaban instrucciones m√°s legibles a esas operaciones (por ejemplo, `MOV`, `ADD`, `JMP`).
- Los **programadores eran, en realidad, ingenieros electr√≥nicos o matem√°ticos** que conoc√≠an el hardware a fondo y escrib√≠an el c√≥digo con papel y l√°piz antes de ingresarlo manualmente.
- **Cada programa era √∫nico y hecho a medida para una m√°quina espec√≠fica.** No exist√≠a portabilidad.

---

#### ‚ö†Ô∏è Problemas frecuentes

- **Alta tasa de errores.** Era f√°cil equivocarse, y no hab√≠a forma r√°pida de verificar o depurar el c√≥digo.
- **Dif√≠cil mantenimiento.** Un cambio en el hardware implicaba volver a escribir el programa desde cero.
- **No hab√≠a herramientas ni metodolog√≠as.** Todo el proceso era artesanal.
- **Tiempo de desarrollo muy largo.** Solo lograr que un programa funcionara correctamente pod√≠a llevar semanas o meses.

---

#### üß™ Ejemplos

- **ENIAC:** Para programarla se requer√≠a literalmente enchufar cables y configurar interruptores manualmente.
- **IBM 701 (1952):** Una de las primeras m√°quinas con programaci√≥n m√°s accesible, pero a√∫n se necesitaban conocimientos t√©cnicos profundos.
- **FORTRAN (1957):** Primer lenguaje de alto nivel. Marc√≥ el inicio de una nueva era al permitir a los cient√≠ficos y matem√°ticos escribir c√≥digo m√°s comprensible.

---

#### üßæ Conclusi√≥n de esta etapa

Esta √©poca sent√≥ las **bases del software** pero tambi√©n mostr√≥ sus **limitaciones**. A medida que los sistemas se hicieron m√°s grandes y m√°s necesarios para la industria, surgi√≥ la necesidad de **formalizar el proceso de desarrollo** y separar roles: nac√≠a as√≠ la disciplina que hoy llamamos Ingenier√≠a de Software.

---

### üö® 2. La crisis del software (finales de los 60s)

Durante la d√©cada de 1960, la computaci√≥n comenz√≥ a expandirse r√°pidamente a nuevos sectores, y los sistemas de software crecieron en tama√±o, complejidad y criticidad. Sin embargo, las pr√°cticas de desarrollo no evolucionaron al mismo ritmo, lo que llev√≥ a una etapa cr√≠tica en la historia de la inform√°tica: **la crisis del software**.

---

#### üìà ¬øQu√© estaba pasando?

- Las empresas y gobiernos empezaban a depender del software para tareas clave.
- Los sistemas requer√≠an decenas o cientos de miles de l√≠neas de c√≥digo.
- Se trabajaba sin planificaci√≥n estructurada ni roles diferenciados.
- Aumentaban los fracasos de proyectos grandes y ambiciosos.

---

#### ‚ö†Ô∏è Problemas recurrentes

- **Proyectos que nunca terminaban.** El tiempo estimado se triplicaba o m√°s.
- **Costos fuera de control.** Presupuestos que se multiplicaban.
- **Fallos graves en producci√≥n.** Software que funcionaba mal o no funcionaba en absoluto.
- **Baja calidad.** Dif√≠cil de mantener, corregir o extender.
- **Falta de documentaci√≥n.** Nadie m√°s pod√≠a entender el sistema una vez terminado.

---

#### üèõ Un hito hist√≥rico: la conferencia de 1968

En 1968 se llev√≥ a cabo la **Primera Conferencia sobre Ingenier√≠a de Software** organizada por la OTAN (NATO) en Garmisch, Alemania.

> All√≠ se utiliz√≥ por primera vez el t√©rmino **‚Äúcrisis del software‚Äù** para describir estos problemas generalizados.

La conferencia fue un punto de inflexi√≥n que reconoci√≥ al software como un **producto complejo** que requer√≠a m√©todos, herramientas, est√°ndares y gesti√≥n profesional.

---

#### üõ† Soluciones propuestas en ese entonces

- Tratar el desarrollo de software como una **disciplina de ingenier√≠a.**
- Introducir modelos de desarrollo estructurados.
- Documentar mejor los procesos.
- Separar roles (analista, dise√±ador, programador, tester).
- Crear herramientas para asistir al desarrollo y seguimiento de proyectos.

---

#### üßæ Consecuencias

- Nacimiento formal de la **Ingenier√≠a de Software** como campo acad√©mico y profesional.
- Surgimiento de metodolog√≠as como el **modelo en cascada**.
- Primeros est√°ndares de calidad y pr√°cticas de gesti√≥n de proyectos.
- Mayor preocupaci√≥n por el **mantenimiento del software** a largo plazo.

---

#### üìå Reflexi√≥n

> La crisis del software mostr√≥ que el **problema no era la tecnolog√≠a**, sino **c√≥mo se organizaban las personas para construirla**.

Fue el punto de partida para replantear todo el proceso de desarrollo, y su legado sigue influyendo en c√≥mo creamos software hoy.

---


### üèó 3. Nacimiento de la Ingenier√≠a de Software (1970s)

La d√©cada de 1970 marc√≥ el nacimiento formal de la **Ingenier√≠a de Software** como disciplina. Esta surgi√≥ como una respuesta directa a los problemas expuestos durante la crisis del software de los a√±os 60. Se entendi√≥ que el desarrollo de software no pod√≠a seguir siendo una actividad improvisada, sino que requer√≠a principios, m√©todos y herramientas propias de la ingenier√≠a.

---

#### üöÄ Cambio de paradigma

- Se empieza a considerar al software como un **producto complejo y estrat√©gico**, no solo como un conjunto de instrucciones.
- El proceso de creaci√≥n de software se ve como una **actividad organizada**, planificada y medible.
- Se reconoce la necesidad de **roles especializados**: analistas, dise√±adores, programadores, testers, gerentes de proyecto.

---

#### üß© Conceptos fundamentales introducidos

Durante esta etapa, se introducen y formalizan varios conceptos clave que a√∫n hoy forman la base de la Ingenier√≠a de Software:

- **Ciclo de vida del software:** el proceso completo desde la concepci√≥n hasta el retiro del sistema.
- **Modelos de desarrollo:** formas de organizar las etapas del ciclo de vida (como el modelo en cascada).
- **Gesti√≥n de proyectos:** planificaci√≥n, control de tiempos, costos, recursos y riesgos.
- **Calidad del software:** se empiezan a definir atributos como mantenibilidad, fiabilidad, eficiencia y usabilidad.

---

#### üõ† Nuevas pr√°cticas y herramientas

- Se desarrollan las primeras metodolog√≠as estructuradas.
- Aparecen los primeros lenguajes de programaci√≥n modernos como **Pascal**.
- Se comienza a documentar cada etapa del proceso (requisitos, dise√±o, pruebas).
- Se crean herramientas b√°sicas de asistencia al desarrollo (editores, compiladores, analizadores).

---

#### üß™ Casos relevantes

- **Modelo en cascada (Waterfall Model):** propuesto por Winston Royce en 1970. Fue el primer modelo ampliamente aceptado y describe el desarrollo en fases secuenciales.
- **Est√°ndares emergentes:** comienzan los esfuerzos por estandarizar procesos y calidad del software, especialmente en √°mbitos militares y aeroespaciales.

---

#### üìå Impacto a largo plazo

- La Ingenier√≠a de Software como carrera y disciplina acad√©mica comienza a ense√±arse en universidades.
- Se crean revistas cient√≠ficas y conferencias especializadas.
- Las empresas grandes (IBM, Bell Labs, etc.) crean divisiones dedicadas exclusivamente al software.

---

#### üí¨ Frase representativa

> "El software debe ser dise√±ado, no ensamblado a los golpes."  
> ‚Äî Glenford Myers

Esta etapa sent√≥ las bases para todo el desarrollo posterior en la disciplina y fue clave para profesionalizar el desarrollo de software.

---

---

### üíª 4. Evoluci√≥n de paradigmas y herramientas (1980‚Äì2000)

Durante las d√©cadas de 1980 y 1990, la Ingenier√≠a de Software experiment√≥ un crecimiento explosivo. Aparecieron nuevos **paradigmas de programaci√≥n**, **herramientas de apoyo al desarrollo** y **lenguajes m√°s poderosos**, lo que permiti√≥ construir sistemas m√°s grandes, robustos y con mejor experiencia para el usuario final.

---

#### üîÄ Programaci√≥n estructurada

- Basada en la idea de **dividir un programa en bloques l√≥gicos**, como funciones o procedimientos.
- Se eliminan los saltos incontrolados (`GOTO`) para mejorar la legibilidad y mantenibilidad.
- Lenguajes clave: **Pascal**, **C**, **Ada**.
- Enfatiza el **control de flujo** estructurado (secuencias, decisiones, bucles).

---

#### üß± Desarrollo orientado a objetos (OOP)

- Introduce el concepto de **objeto** como combinaci√≥n de datos + comportamiento.
- Principios fundamentales:
  - **Encapsulamiento**
  - **Herencia**
  - **Polimorfismo**
- Mejora la **modularidad**, la **reutilizaci√≥n** y la **escalabilidad** del software.
- Lenguajes clave: **Smalltalk**, **C++**, **Java** (m√°s adelante Python).
- La OOP se convierte en el enfoque dominante durante los a√±os 90.

---

#### üõ† Herramientas CASE (Computer-Aided Software Engineering)

- Herramientas para asistir en distintas etapas del desarrollo:
  - Modelado (diagramas, UML)
  - Generaci√≥n de c√≥digo
  - Control de versiones
  - Documentaci√≥n autom√°tica
- Ejemplos: Rational Rose, PowerDesigner, Visual Paradigm.
- Se buscaba aumentar la **productividad** y reducir los **errores humanos** mediante automatizaci√≥n.

---

#### üí¨ Lenguajes de programaci√≥n clave

- **C (1972):** eficiencia, uso en sistemas operativos.
- **C++ (1983):** extensi√≥n orientada a objetos de C.
- **Java (1995):** multiplataforma, seguro, orientado a objetos puro.
- **Visual Basic (1991):** entornos gr√°ficos accesibles para desarrollo r√°pido (RAD).

---

#### üß© Nuevas tecnolog√≠as adoptadas

- **Bases de datos relacionales** (SQL, Oracle, MySQL): separaci√≥n l√≥gica de datos y l√≥gica del programa.
- **Interfaces gr√°ficas de usuario (GUI):** mejora radical en la experiencia del usuario.
- **Sistemas distribuidos:** software que funciona en m√∫ltiples computadoras conectadas en red.
- **Patrones de dise√±o:** soluciones reutilizables para problemas comunes de dise√±o de software.

---

#### üßæ Impacto general

- Los proyectos empiezan a escalar en tama√±o y alcance.
- Se desarrollan suites completas de software empresarial (ERPs, CRMs).
- Se afianza el rol del **ingeniero de software** como figura profesional clave.
- Comienza a definirse la **ingenier√≠a de requisitos**, **pruebas de software**, y **m√©tricas de calidad** como √°reas propias.

---

#### üìå Frase destacada

> "El software moderno no se escribe solo con l√≠neas de c√≥digo, sino con ideas bien organizadas, herramientas adecuadas y estructuras que permitan evolucionar."

---

### üåê 5. Era moderna (2000 - Actualidad)

Con la llegada del nuevo milenio, la Ingenier√≠a de Software entr√≥ en una etapa marcada por la **velocidad**, la **conectividad**, y la **orientaci√≥n al usuario**. La demanda de software confiable, usable y constantemente actualizado llev√≥ al surgimiento de nuevos enfoques y herramientas para el desarrollo y despliegue de sistemas.

---

#### ‚ö° Desarrollo √°gil y metodolog√≠as iterativas

- En 2001 se publica el **Manifiesto √Ågil**, que impulsa un enfoque centrado en:
  - Personas y colaboraci√≥n sobre procesos r√≠gidos.
  - Software funcional sobre documentaci√≥n excesiva.
  - Respuesta al cambio sobre seguir un plan fijo.
  - Interacci√≥n con el cliente constante.
- Metodolog√≠as populares: **Scrum**, **Kanban**, **Extreme Programming (XP)**.
- El desarrollo se organiza en ciclos cortos llamados **sprints**, donde se entrega funcionalidad incremental.

---

#### ü§ñ Pruebas automatizadas, integraci√≥n continua y DevOps

- Se automatiza la ejecuci√≥n de pruebas para verificar funcionalidades de forma r√°pida y frecuente.
- **Integraci√≥n continua (CI):** cada cambio en el c√≥digo se integra, prueba y valida autom√°ticamente.
- **Entrega continua (CD):** se puede desplegar software nuevo en producci√≥n de forma confiable.
- **DevOps:** cultura que une desarrollo (Dev) y operaciones (Ops), automatizando el ciclo completo desde el desarrollo hasta la puesta en producci√≥n.

---

#### ‚òÅÔ∏è Software como Servicio (SaaS)

- El software deja de instalarse localmente y pasa a usarse desde la web.
- Ventajas:
  - Acceso desde cualquier lugar.
  - Actualizaciones autom√°ticas.
  - Menores costos iniciales.
- Ejemplos: **Google Workspace, Trello, Dropbox, Zoom.**

---

#### üì± Aplicaciones m√≥viles y en la nube

- Con la masificaci√≥n de los smartphones (desde 2007 con el iPhone), el software se adapta a nuevos dispositivos.
- Se desarrolla para m√∫ltiples plataformas (Android, iOS, navegadores).
- La **nube** (cloud computing) permite escalar aplicaciones a millones de usuarios y almacenar grandes vol√∫menes de datos.
- Plataformas populares: **AWS, Azure, Google Cloud.**

---

#### ü§ñ Incorporaci√≥n de tecnolog√≠as emergentes

- **Inteligencia Artificial (IA):** sistemas que aprenden y toman decisiones (ej. recomendadores, chatbots).
- **Big Data:** an√°lisis de enormes vol√∫menes de datos en tiempo real.
- **Blockchain:** registro descentralizado, utilizado en criptomonedas y trazabilidad.
- Estas tecnolog√≠as requieren software altamente especializado y nuevas formas de dise√±o.

---

#### üßë‚Äçüíª Enfoque en la experiencia del usuario (UX)

- Se prioriza la **usabilidad**, **accesibilidad** y **est√©tica** de las aplicaciones.
- El software se dise√±a pensando en las personas, sus necesidades y comportamientos.
- Se aplican t√©cnicas como dise√±o centrado en el usuario, prototipado, testing de interfaces, etc.

---

#### üßæ Consecuencias de esta era

- El software est√° presente en **todos los aspectos de la vida**.
- El desarrollo debe ser r√°pido, adaptable y escalable.
- El trabajo en equipo y la colaboraci√≥n remota son esenciales.
- Se valora la **calidad continua**, m√°s all√° de la entrega inicial.

---

#### üìå Frase destacada

> ‚ÄúEn el siglo XXI, las empresas que no piensan como desarrolladoras de software est√°n destinadas a desaparecer.‚Äù

---

## üß≠ Lecciones aprendidas de la historia

El recorrido hist√≥rico del software desde sus or√≠genes hasta la actualidad deja en evidencia una serie de lecciones fundamentales para cualquier profesional del desarrollo:

- **La complejidad del software solo crece.**  
  Cada vez se desarrollan sistemas m√°s grandes, con m√°s funcionalidades, y que deben integrarse con otras tecnolog√≠as. Esto requiere enfoques m√°s estructurados y maduros.

- **La improvisaci√≥n lleva al fracaso.**  
  La experiencia hist√≥rica demostr√≥ que sin planificaci√≥n, sin roles definidos y sin metodolog√≠as adecuadas, los proyectos tienden al caos, superan presupuestos o directamente no se completan.

- **El trabajo en equipo y la comunicaci√≥n son tan importantes como la tecnolog√≠a.**  
  Los problemas m√°s frecuentes en los proyectos no se deben a fallas t√©cnicas, sino a errores de comunicaci√≥n, mal entendimiento de los requerimientos o falta de coordinaci√≥n.

- **La evoluci√≥n tecnol√≥gica exige actualizaci√≥n constante.**  
  Nuevos lenguajes, entornos y metodolog√≠as aparecen constantemente. La formaci√≥n continua es clave para mantenerse vigente como profesional.

---

## üß† Conceptos clave introducidos

A lo largo de esta clase se introdujeron ideas centrales que ser√°n desarrolladas en profundidad en las siguientes unidades:

- **Crisis del software:**  
  Un punto de inflexi√≥n en la historia de la inform√°tica que evidenci√≥ los problemas graves de la improvisaci√≥n en proyectos de desarrollo.

- **Ingenier√≠a de software como disciplina:**  
  Surgimiento de un enfoque profesional, sistem√°tico y multidisciplinario para construir software confiable y de calidad.

- **Evoluci√≥n de modelos y metodolog√≠as:**  
  Desde la programaci√≥n estructurada hasta el desarrollo √°gil y DevOps, el software ha atravesado m√∫ltiples paradigmas que respondieron a las necesidades de cada √©poca.

- **Importancia del proceso de desarrollo:**  
  El producto final depende directamente de c√≥mo se organiza el proceso. Planificaci√≥n, dise√±o, pruebas, mantenimiento y mejora continua son partes esenciales del ciclo de vida del software.

---

Estas ideas servir√°n de base para entender los modelos de ciclo de vida, las tecnolog√≠as de desarrollo, la gesti√≥n de proyectos y la evoluci√≥n del software que se ver√°n en las pr√≥ximas clases.


## ‚úçÔ∏è Actividad sugerida

Investigaci√≥n individual:
> Eleg√≠ un sistema de software moderno (Netflix, Google Maps, WhatsApp, etc.) y describ√≠ qu√© tan complejo pens√°s que es por dentro. ¬øQu√© tipos de equipos, herramientas y procesos imagin√°s que usan para mantenerlo funcionando?

---

## üìö Lecturas sugeridas

- Sommerville, Ian. *Ingenier√≠a del Software* - Cap. 1 y 2
- Art√≠culo: "Software Engineering: The Past and the Future" ‚Äì IEEE Software

---

