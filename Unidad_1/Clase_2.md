# Clase 2 - EvoluciÃ³n HistÃ³rica del Software y el Surgimiento de la IngenierÃ­a de Software

---

## ğŸ¯ Objetivo de la clase

Conocer el contexto histÃ³rico que dio origen a la IngenierÃ­a de Software, entender la evoluciÃ³n del software y por quÃ© se hizo necesario un enfoque mÃ¡s sistemÃ¡tico y profesional para su desarrollo.

---

## ğŸ•° Etapas de la evoluciÃ³n del software

### ğŸ§® 1. Los comienzos (dÃ©cadas de 1950-60)

Durante los primeros aÃ±os de la computaciÃ³n, el desarrollo de software no existÃ­a como una actividad separada. Las computadoras eran muy costosas, enormes y difÃ­ciles de operar, y se usaban principalmente con fines cientÃ­ficos, militares o administrativos.

---

#### ğŸ“ Contexto general

- Las computadoras eran **electromecÃ¡nicas o a vÃ¡lvulas**, como la ENIAC (1946) o la UNIVAC.
- El acceso era limitado: solo grandes instituciones (gobiernos, universidades, empresas multinacionales) podÃ­an adquirirlas.
- No existÃ­a el concepto de â€œusuarioâ€ como lo entendemos hoy.

---

#### ğŸ’» Â¿CÃ³mo se desarrollaba el software?

- **El software no se "programaba" como hoy.** Se ingresaban instrucciones directamente en lenguaje de mÃ¡quina: cadenas de 0s y 1s que el procesador podÃ­a entender.
- Luego surgieron **lenguajes ensambladores**, que asignaban instrucciones mÃ¡s legibles a esas operaciones (por ejemplo, `MOV`, `ADD`, `JMP`).
- Los **programadores eran, en realidad, ingenieros electrÃ³nicos o matemÃ¡ticos** que conocÃ­an el hardware a fondo y escribÃ­an el cÃ³digo con papel y lÃ¡piz antes de ingresarlo manualmente.
- **Cada programa era Ãºnico y hecho a medida para una mÃ¡quina especÃ­fica.** No existÃ­a portabilidad.

---

#### âš ï¸ Problemas frecuentes

- **Alta tasa de errores.** Era fÃ¡cil equivocarse, y no habÃ­a forma rÃ¡pida de verificar o depurar el cÃ³digo.
- **DifÃ­cil mantenimiento.** Un cambio en el hardware implicaba volver a escribir el programa desde cero.
- **No habÃ­a herramientas ni metodologÃ­as.** Todo el proceso era artesanal.
- **Tiempo de desarrollo muy largo.** Solo lograr que un programa funcionara correctamente podÃ­a llevar semanas o meses.

---

#### ğŸ§ª Ejemplos

- **ENIAC:** Para programarla se requerÃ­a literalmente enchufar cables y configurar interruptores manualmente.
- **IBM 701 (1952):** Una de las primeras mÃ¡quinas con programaciÃ³n mÃ¡s accesible, pero aÃºn se necesitaban conocimientos tÃ©cnicos profundos.
- **FORTRAN (1957):** Primer lenguaje de alto nivel. MarcÃ³ el inicio de una nueva era al permitir a los cientÃ­ficos y matemÃ¡ticos escribir cÃ³digo mÃ¡s comprensible.

---

#### ğŸ§¾ ConclusiÃ³n de esta etapa

Esta Ã©poca sentÃ³ las **bases del software** pero tambiÃ©n mostrÃ³ sus **limitaciones**. A medida que los sistemas se hicieron mÃ¡s grandes y mÃ¡s necesarios para la industria, surgiÃ³ la necesidad de **formalizar el proceso de desarrollo** y separar roles: nacÃ­a asÃ­ la disciplina que hoy llamamos IngenierÃ­a de Software.

---

### ğŸš¨ 2. La crisis del software (finales de los 60s)

Durante la dÃ©cada de 1960, la computaciÃ³n comenzÃ³ a expandirse rÃ¡pidamente a nuevos sectores, y los sistemas de software crecieron en tamaÃ±o, complejidad y criticidad. Sin embargo, las prÃ¡cticas de desarrollo no evolucionaron al mismo ritmo, lo que llevÃ³ a una etapa crÃ­tica en la historia de la informÃ¡tica: **la crisis del software**.

---

#### ğŸ“ˆ Â¿QuÃ© estaba pasando?

- Las empresas y gobiernos empezaban a depender del software para tareas clave.
- Los sistemas requerÃ­an decenas o cientos de miles de lÃ­neas de cÃ³digo.
- Se trabajaba sin planificaciÃ³n estructurada ni roles diferenciados.
- Aumentaban los fracasos de proyectos grandes y ambiciosos.

---

#### âš ï¸ Problemas recurrentes

- **Proyectos que nunca terminaban.** El tiempo estimado se triplicaba o mÃ¡s.
- **Costos fuera de control.** Presupuestos que se multiplicaban.
- **Fallos graves en producciÃ³n.** Software que funcionaba mal o no funcionaba en absoluto.
- **Baja calidad.** DifÃ­cil de mantener, corregir o extender.
- **Falta de documentaciÃ³n.** Nadie mÃ¡s podÃ­a entender el sistema una vez terminado.

---

#### ğŸ› Un hito histÃ³rico: la conferencia de 1968

En 1968 se llevÃ³ a cabo la **Primera Conferencia sobre IngenierÃ­a de Software** organizada por la OTAN (NATO) en Garmisch, Alemania.

> AllÃ­ se utilizÃ³ por primera vez el tÃ©rmino **â€œcrisis del softwareâ€** para describir estos problemas generalizados.

La conferencia fue un punto de inflexiÃ³n que reconociÃ³ al software como un **producto complejo** que requerÃ­a mÃ©todos, herramientas, estÃ¡ndares y gestiÃ³n profesional.

---

#### ğŸ›  Soluciones propuestas en ese entonces

- Tratar el desarrollo de software como una **disciplina de ingenierÃ­a.**
- Introducir modelos de desarrollo estructurados.
- Documentar mejor los procesos.
- Separar roles (analista, diseÃ±ador, programador, tester).
- Crear herramientas para asistir al desarrollo y seguimiento de proyectos.

---

#### ğŸ§¾ Consecuencias

- Nacimiento formal de la **IngenierÃ­a de Software** como campo acadÃ©mico y profesional.
- Surgimiento de metodologÃ­as como el **modelo en cascada**.
- Primeros estÃ¡ndares de calidad y prÃ¡cticas de gestiÃ³n de proyectos.
- Mayor preocupaciÃ³n por el **mantenimiento del software** a largo plazo.

---

#### ğŸ“Œ ReflexiÃ³n

> La crisis del software mostrÃ³ que el **problema no era la tecnologÃ­a**, sino **cÃ³mo se organizaban las personas para construirla**.

Fue el punto de partida para replantear todo el proceso de desarrollo, y su legado sigue influyendo en cÃ³mo creamos software hoy.

---


### ğŸ— 3. Nacimiento de la IngenierÃ­a de Software (1970s)

La dÃ©cada de 1970 marcÃ³ el nacimiento formal de la **IngenierÃ­a de Software** como disciplina. Esta surgiÃ³ como una respuesta directa a los problemas expuestos durante la crisis del software de los aÃ±os 60. Se entendiÃ³ que el desarrollo de software no podÃ­a seguir siendo una actividad improvisada, sino que requerÃ­a principios, mÃ©todos y herramientas propias de la ingenierÃ­a.

---

#### ğŸš€ Cambio de paradigma

- Se empieza a considerar al software como un **producto complejo y estratÃ©gico**, no solo como un conjunto de instrucciones.
- El proceso de creaciÃ³n de software se ve como una **actividad organizada**, planificada y medible.
- Se reconoce la necesidad de **roles especializados**: analistas, diseÃ±adores, programadores, testers, gerentes de proyecto.

---

#### ğŸ§© Conceptos fundamentales introducidos

Durante esta etapa, se introducen y formalizan varios conceptos clave que aÃºn hoy forman la base de la IngenierÃ­a de Software:

- **Ciclo de vida del software:** el proceso completo desde la concepciÃ³n hasta el retiro del sistema.
- **Modelos de desarrollo:** formas de organizar las etapas del ciclo de vida (como el modelo en cascada).
- **GestiÃ³n de proyectos:** planificaciÃ³n, control de tiempos, costos, recursos y riesgos.
- **Calidad del software:** se empiezan a definir atributos como mantenibilidad, fiabilidad, eficiencia y usabilidad.

---

#### ğŸ›  Nuevas prÃ¡cticas y herramientas

- Se desarrollan las primeras metodologÃ­as estructuradas.
- Aparecen los primeros lenguajes de programaciÃ³n modernos como **Pascal**.
- Se comienza a documentar cada etapa del proceso (requisitos, diseÃ±o, pruebas).
- Se crean herramientas bÃ¡sicas de asistencia al desarrollo (editores, compiladores, analizadores).

---

#### ğŸ§ª Casos relevantes

- **Modelo en cascada (Waterfall Model):** propuesto por Winston Royce en 1970. Fue el primer modelo ampliamente aceptado y describe el desarrollo en fases secuenciales.
- **EstÃ¡ndares emergentes:** comienzan los esfuerzos por estandarizar procesos y calidad del software, especialmente en Ã¡mbitos militares y aeroespaciales.

---

#### ğŸ“Œ Impacto a largo plazo

- La IngenierÃ­a de Software como carrera y disciplina acadÃ©mica comienza a enseÃ±arse en universidades.
- Se crean revistas cientÃ­ficas y conferencias especializadas.
- Las empresas grandes (IBM, Bell Labs, etc.) crean divisiones dedicadas exclusivamente al software.

---

#### ğŸ’¬ Frase representativa

> "El software debe ser diseÃ±ado, no ensamblado a los golpes."  
> â€” Glenford Myers

Esta etapa sentÃ³ las bases para todo el desarrollo posterior en la disciplina y fue clave para profesionalizar el desarrollo de software.

---

---

### ğŸ’» 4. EvoluciÃ³n de paradigmas y herramientas (1980â€“2000)

Durante las dÃ©cadas de 1980 y 1990, la IngenierÃ­a de Software experimentÃ³ un crecimiento explosivo. Aparecieron nuevos **paradigmas de programaciÃ³n**, **herramientas de apoyo al desarrollo** y **lenguajes mÃ¡s poderosos**, lo que permitiÃ³ construir sistemas mÃ¡s grandes, robustos y con mejor experiencia para el usuario final.

---

#### ğŸ”€ ProgramaciÃ³n estructurada

- Basada en la idea de **dividir un programa en bloques lÃ³gicos**, como funciones o procedimientos.
- Se eliminan los saltos incontrolados (`GOTO`) para mejorar la legibilidad y mantenibilidad.
- Lenguajes clave: **Pascal**, **C**, **Ada**.
- Enfatiza el **control de flujo** estructurado (secuencias, decisiones, bucles).

---

#### ğŸ§± Desarrollo orientado a objetos (OOP)

- Introduce el concepto de **objeto** como combinaciÃ³n de datos + comportamiento.
- Principios fundamentales:
  - **Encapsulamiento**
  - **Herencia**
  - **Polimorfismo**
- Mejora la **modularidad**, la **reutilizaciÃ³n** y la **escalabilidad** del software.
- Lenguajes clave: **Smalltalk**, **C++**, **Java** (mÃ¡s adelante Python).
- La OOP se convierte en el enfoque dominante durante los aÃ±os 90.

---

#### ğŸ›  Herramientas CASE (Computer-Aided Software Engineering)

- Herramientas para asistir en distintas etapas del desarrollo:
  - Modelado (diagramas, UML)
  - GeneraciÃ³n de cÃ³digo
  - Control de versiones
  - DocumentaciÃ³n automÃ¡tica
- Ejemplos: Rational Rose, PowerDesigner, Visual Paradigm.
- Se buscaba aumentar la **productividad** y reducir los **errores humanos** mediante automatizaciÃ³n.

---

#### ğŸ’¬ Lenguajes de programaciÃ³n clave

- **C (1972):** eficiencia, uso en sistemas operativos.
- **C++ (1983):** extensiÃ³n orientada a objetos de C.
- **Java (1995):** multiplataforma, seguro, orientado a objetos puro.
- **Visual Basic (1991):** entornos grÃ¡ficos accesibles para desarrollo rÃ¡pido (RAD).

---

#### ğŸ§© Nuevas tecnologÃ­as adoptadas

- **Bases de datos relacionales** (SQL, Oracle, MySQL): separaciÃ³n lÃ³gica de datos y lÃ³gica del programa.
- **Interfaces grÃ¡ficas de usuario (GUI):** mejora radical en la experiencia del usuario.
- **Sistemas distribuidos:** software que funciona en mÃºltiples computadoras conectadas en red.
- **Patrones de diseÃ±o:** soluciones reutilizables para problemas comunes de diseÃ±o de software.

---

#### ğŸ§¾ Impacto general

- Los proyectos empiezan a escalar en tamaÃ±o y alcance.
- Se desarrollan suites completas de software empresarial (ERPs, CRMs).
- Se afianza el rol del **ingeniero de software** como figura profesional clave.
- Comienza a definirse la **ingenierÃ­a de requisitos**, **pruebas de software**, y **mÃ©tricas de calidad** como Ã¡reas propias.

---

#### ğŸ“Œ Frase destacada

> "El software moderno no se escribe solo con lÃ­neas de cÃ³digo, sino con ideas bien organizadas, herramientas adecuadas y estructuras que permitan evolucionar."

---

### ğŸŒ 5. Era moderna (2000 - Actualidad)

Con la llegada del nuevo milenio, la IngenierÃ­a de Software entrÃ³ en una etapa marcada por la **velocidad**, la **conectividad**, y la **orientaciÃ³n al usuario**. La demanda de software confiable, usable y constantemente actualizado llevÃ³ al surgimiento de nuevos enfoques y herramientas para el desarrollo y despliegue de sistemas.

---

#### âš¡ Desarrollo Ã¡gil y metodologÃ­as iterativas

- En 2001 se publica el **Manifiesto Ãgil**, que impulsa un enfoque centrado en:
  - Personas y colaboraciÃ³n sobre procesos rÃ­gidos.
  - Software funcional sobre documentaciÃ³n excesiva.
  - Respuesta al cambio sobre seguir un plan fijo.
  - InteracciÃ³n con el cliente constante.
- MetodologÃ­as populares: **Scrum**, **Kanban**, **Extreme Programming (XP)**.
- El desarrollo se organiza en ciclos cortos llamados **sprints**, donde se entrega funcionalidad incremental.

---

#### ğŸ¤– Pruebas automatizadas, integraciÃ³n continua y DevOps

- Se automatiza la ejecuciÃ³n de pruebas para verificar funcionalidades de forma rÃ¡pida y frecuente.
- **IntegraciÃ³n continua (CI):** cada cambio en el cÃ³digo se integra, prueba y valida automÃ¡ticamente.
- **Entrega continua (CD):** se puede desplegar software nuevo en producciÃ³n de forma confiable.
- **DevOps:** cultura que une desarrollo (Dev) y operaciones (Ops), automatizando el ciclo completo desde el desarrollo hasta la puesta en producciÃ³n.

---

#### â˜ï¸ Software como Servicio (SaaS)

- El software deja de instalarse localmente y pasa a usarse desde la web.
- Ventajas:
  - Acceso desde cualquier lugar.
  - Actualizaciones automÃ¡ticas.
  - Menores costos iniciales.
- Ejemplos: **Google Workspace, Trello, Dropbox, Zoom.**

---

#### ğŸ“± Aplicaciones mÃ³viles y en la nube

- Con la masificaciÃ³n de los smartphones (desde 2007 con el iPhone), el software se adapta a nuevos dispositivos.
- Se desarrolla para mÃºltiples plataformas (Android, iOS, navegadores).
- La **nube** (cloud computing) permite escalar aplicaciones a millones de usuarios y almacenar grandes volÃºmenes de datos.
- Plataformas populares: **AWS, Azure, Google Cloud.**

---

#### ğŸ¤– IncorporaciÃ³n de tecnologÃ­as emergentes

- **Inteligencia Artificial (IA):** sistemas que aprenden y toman decisiones (ej. recomendadores, chatbots).
- **Big Data:** anÃ¡lisis de enormes volÃºmenes de datos en tiempo real.
- **Blockchain:** registro descentralizado, utilizado en criptomonedas y trazabilidad.
- Estas tecnologÃ­as requieren software altamente especializado y nuevas formas de diseÃ±o.

---

#### ğŸ§‘â€ğŸ’» Enfoque en la experiencia del usuario (UX)

- Se prioriza la **usabilidad**, **accesibilidad** y **estÃ©tica** de las aplicaciones.
- El software se diseÃ±a pensando en las personas, sus necesidades y comportamientos.
- Se aplican tÃ©cnicas como diseÃ±o centrado en el usuario, prototipado, testing de interfaces, etc.

---

#### ğŸ§¾ Consecuencias de esta era

- El software estÃ¡ presente en **todos los aspectos de la vida**.
- El desarrollo debe ser rÃ¡pido, adaptable y escalable.
- El trabajo en equipo y la colaboraciÃ³n remota son esenciales.
- Se valora la **calidad continua**, mÃ¡s allÃ¡ de la entrega inicial.

---

#### ğŸ“Œ Frase destacada

> â€œEn el siglo XXI, las empresas que no piensan como desarrolladoras de software estÃ¡n destinadas a desaparecer.â€

---

## ğŸ§­ Lecciones aprendidas de la historia

El recorrido histÃ³rico del software desde sus orÃ­genes hasta la actualidad deja en evidencia una serie de lecciones fundamentales para cualquier profesional del desarrollo:

- **La complejidad del software solo crece.**  
  Cada vez se desarrollan sistemas mÃ¡s grandes, con mÃ¡s funcionalidades, y que deben integrarse con otras tecnologÃ­as. Esto requiere enfoques mÃ¡s estructurados y maduros.

- **La improvisaciÃ³n lleva al fracaso.**  
  La experiencia histÃ³rica demostrÃ³ que sin planificaciÃ³n, sin roles definidos y sin metodologÃ­as adecuadas, los proyectos tienden al caos, superan presupuestos o directamente no se completan.

- **El trabajo en equipo y la comunicaciÃ³n son tan importantes como la tecnologÃ­a.**  
  Los problemas mÃ¡s frecuentes en los proyectos no se deben a fallas tÃ©cnicas, sino a errores de comunicaciÃ³n, mal entendimiento de los requerimientos o falta de coordinaciÃ³n.

- **La evoluciÃ³n tecnolÃ³gica exige actualizaciÃ³n constante.**  
  Nuevos lenguajes, entornos y metodologÃ­as aparecen constantemente. La formaciÃ³n continua es clave para mantenerse vigente como profesional.

---

## ğŸ§  Conceptos clave introducidos

A lo largo de esta clase se introdujeron ideas centrales que serÃ¡n desarrolladas en profundidad en las siguientes unidades:

- **Crisis del software:**  
  Un punto de inflexiÃ³n en la historia de la informÃ¡tica que evidenciÃ³ los problemas graves de la improvisaciÃ³n en proyectos de desarrollo.

- **IngenierÃ­a de software como disciplina:**  
  Surgimiento de un enfoque profesional, sistemÃ¡tico y multidisciplinario para construir software confiable y de calidad.

- **EvoluciÃ³n de modelos y metodologÃ­as:**  
  Desde la programaciÃ³n estructurada hasta el desarrollo Ã¡gil y DevOps, el software ha atravesado mÃºltiples paradigmas que respondieron a las necesidades de cada Ã©poca.

- **Importancia del proceso de desarrollo:**  
  El producto final depende directamente de cÃ³mo se organiza el proceso. PlanificaciÃ³n, diseÃ±o, pruebas, mantenimiento y mejora continua son partes esenciales del ciclo de vida del software.

---

Estas ideas servirÃ¡n de base para entender los modelos de ciclo de vida, las tecnologÃ­as de desarrollo, la gestiÃ³n de proyectos y la evoluciÃ³n del software que se verÃ¡n en las prÃ³ximas clases.


## âœï¸ Actividad sugerida

InvestigaciÃ³n individual:
> ElegÃ­ un sistema de software moderno (Netflix, Google Maps, WhatsApp, etc.) y describÃ­ quÃ© tan complejo pensÃ¡s que es por dentro. Â¿QuÃ© tipos de equipos, herramientas y procesos imaginÃ¡s que usan para mantenerlo funcionando?

---

## ğŸ“š Lecturas sugeridas

- Sommerville, Ian. *IngenierÃ­a del Software* - Cap. 1 y 2
- ArtÃ­culo: "Software Engineering: The Past and the Future" â€“ IEEE Software

---

